DSL & 命名规范
覆盖度：核心缩写表已有人手定义，但距离 PRD 的“全 CSS 覆盖”还有差距——autoAbbr 仅从浏览器 style 原型推断可用属性，缺少对未被当前 UA 支持、但在 MDN 里的属性的兜底注册；自动生成的 numericType 统一默认 numberOrLength，无法匹配颜色、URL、keyword-only 等类型。建议：补一份离线的 MDN 属性 → 类型映射表（可 JSON），在初始化时与 UA 提供的属性并集注册，并为不同属性赋予正确的 numericType/原值策略。
命名空间冲突：当前只依靠 resolveAbbrCollision 的 4 位截断去避免缩写撞车，但未区分“伪类/伪元素前缀” vs “属性缩写”命名空间，也没有防止未来新增核心缩写时覆盖 AUTO_ABBR。建议：在注册时维护三个集合（属性缩写 / 伪类前缀 / 伪元素前缀），显式冲突检查，必要时自动加长到 5–6 位而不是硬截 4 位。
语法细节：数值拆分规则使用 lengthList 串联 -（如 p10-20），与常见 CSS 多值的空格分隔不同；PRD 未明确，若希望“更贴近原生”，应支持空格或逗号形式（或允许 [] 原值时直接填 p[10px 20px] 并在文档中说明）。
伪类/伪元素：内置表仅覆盖常用项，尚未穷举 MDN（例如 :scope、:focus-within 已有，但 :fullscreen、:placeholder-shown 有，仍缺如 :host、::part 等 Shadow DOM 相关伪类/伪元素）。建议以 MDN 清单补全并在 PARAMETRIC_* 中支持 Shadow DOM 参数化伪类。
运行时（浏览器）
PRD 要求 “输入 DOM / HTML 字符串” 均可解析。现有 applyLegoFromRoot 只能在浏览器 DOM 上运行，无法接受“纯 HTML 字符串”直接编译。建议：暴露 lego.compileHtml(htmlString, options)，内部用 DOMParser 创建离线文档，复用 tokenizeClassString 提取 class。
伪类 group 语法：h:(...) 已支持并会把展开后的 token 写回 DOM，但原 token 被移除（classList 删除），这会导致 cacheKey 变化（缓存命中率下降）且与“class 里保留 group 原样”预期可能不符。PRD 未要求强制移除，可改为保留原 token 以便回溯。
持久化缓存：使用 localStorage，但 CACHE_VERSION 写死 v3，与 PRD 的“零配置可用”一致，但缺少“选择不同 selectorStrategy 时自动隔离缓存”的说明与测试。建议：文档化 selector 策略差异，或自动包含 runtime 版本号/配置 hash，避免多版本脚本共享同一缓存键。
错误暴露：parseToken 抛错时仅在 debug 模式下 console.warn，无可订阅的错误钩子。可按 PRD “可解释”目标，增加 onError 回调或将错误收集到 window.lego.errors，方便 LLM/开发者调试。
构建期能力
PRD P0 明确需要 @lego/core：compileTokens、scanFiles、简单 Vite 插件/CLI。当前仓库只有浏览器 runtime，完全缺失 Node 侧构建链路。调整方向：
把解析与渲染核心（tokenizeClassString、parseToken、renderRule 等）抽成无 DOM 依赖的模块；
提供 compileTokens(tokens[], { selectorStrategy }) 导出；
简单 scanFiles(globs)：基于正则/HTML parser 抓取 class 字符串，去重后喂给 compileTokens;
Vite 插件：在 transformIndexHtml/transform 阶段收集 token，生成虚拟模块注入样式。
LLM 配套与文档
PRD 要求 llms.txt / llms-full.txt / lego-naming-spec.json 同步更新。当前 docs/legocss.js 未暴露“缩写 → 属性”可机读表，也未生成 llms 文件。建议：
在构建时把 CORE_ABBR + AUTO_ABBR 导出为 JSON，供 lego-naming-spec.json 复用；
生成 llms.txt 时自动插入当前缩写表示例，避免手写过期。
体验差异（Playground/官网）
PRD 需要“左编辑右预览” playground 与 Tailwind 对照表。现 runtime 不包含此 UI，也未有一键导出到 CodePen/Codesandbox 的逻辑。需额外实现（可能在 demo/ 目录或 docs 页面）。
代码回顾

✅ What’s good：
tokenizeClassString 与 expandGroupToken 组合简单易懂，能正确保留 []/() 内空格，符合 DSL 解析需求。
compileClassList 的缓存策略（tokenCache + cacheVersion + Set 去重）让重复 class 编译成本接近 O(1)，且支持 selectorStrategy 切换。
applyLegoFromRoot 里对 group token 展开并同步写回 DOM，用户无需手动拆分伪类组，体验友好。
📝 Suggestions：
将核心解析/render 逻辑拆分成独立模块，浏览器与 Node 共用，避免后续实现 @lego/core 时复制粘贴。
为自动缩写引入可配置的属性 → 类型表，减少对浏览器 UA 的依赖；同时在注册时检测命名冲突。
为错误/未知伪类提供 Hook 或收集机制，利于 LLM/用户调试。
💡 Why it matters：
共用核心可减少浏览器/Node 两套逻辑漂移，保证 PRD 所需“运行时 + 构建时双模式”一致性。
精准的类型信息让自动缩写生成的规则更安全（如颜色、URL 不会被错误地追加 px），更符合“理论覆盖 MDN”的目标。
更好的错误可观测性帮助 LLM 场景快速纠正生成的非法 token，提高成功率 KPI。
🔧 How to improve：
抽出 parseToken、renderRule、getAbbrMeta、autoAbbr 到 core/tokenizer.js（或类似路径），浏览器侧仅保留 DOM 扫描和样式注入。
维护一份 css-props.json（MDN 抓取/手写），启动时 registerAbbr(prop, { numericType })，并在 resolveAbbrCollision 中避免与伪类前缀冲突。
在 compileClassList 增加 onError(err, token) 选项；warnUnknownVariants 可直接把未知前缀推送到 lego.errors。
延伸学习

MDN CSS Reference（https://developer.mozilla.org/en-US/docs/Web/CSS/Reference）— 全属性/伪类/伪元素清单，可用来校准自动缩写表。
web.dev “Authoring maintainable CSS” — 讲解原子化/可组合 CSS 的实践，对设计 DSL 有参考价值。
Tailwind Arbitrary values 指南 — 理解团队为何禁用 [] 语法，帮助在文档里解释 lego.css 的差异化设计。
未执行的验证步骤

当前环境为只读，未运行 npm test / npm run dev；调整完成后请本地执行 npm test 验证基础单测，再用一个包含伪类 group 与 autoAbbr 的示例页面手动回归。
以上差异点是否清晰？如果需要，我可以按优先级给出实施顺序或示例代码。